<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>关于Generator | Risexie</title>
    <meta name="description" content="">
    
    
    <link rel="preload" href="/assets/css/0.styles.01caefc4.css" as="style"><link rel="preload" href="/assets/js/app.56f95d45.js" as="script"><link rel="preload" href="/assets/js/5.08ff075f.js" as="script"><link rel="prefetch" href="/assets/js/4.ab5bcf37.js"><link rel="prefetch" href="/assets/js/1.60b27f52.js"><link rel="prefetch" href="/assets/js/2.87ffcd93.js"><link rel="prefetch" href="/assets/js/3.08b20e69.js"><link rel="prefetch" href="/assets/js/6.abb57fce.js"><link rel="prefetch" href="/assets/js/7.5d8e94ce.js"><link rel="prefetch" href="/assets/js/8.34bb0783.js"><link rel="prefetch" href="/assets/js/9.5924d11a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.01caefc4.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/" class="home-link router-link-active"><!----><span class="site-name">
      Risexie
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><a href="/lists/let与const.html" class="nav-link">Blog</a></div><div class="nav-item"><a href="/about.html" class="nav-link">About</a></div><!----></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><a href="/lists/let与const.html" class="nav-link">Blog</a></div><div class="nav-item"><a href="/about.html" class="nav-link">About</a></div><!----></nav><ul class="sidebar-links"><li><a href="/lists/let与const.html" class="sidebar-link">关于var,let 与const</a></li><li><a href="/lists/关于Promise.html" class="sidebar-link">关于Promise(上)</a></li><li><a href="/lists/关于Promise2.html" class="sidebar-link">关于Promise(下)</a></li><li><a href="/lists/通过十道练习题，看Promise特点.html" class="sidebar-link">通过十道Promise练习题，看Promise特点</a></li><li><a href="/lists/关于Iterator.html" class="sidebar-link">关于interator</a></li><li><a href="/lists/关于Generator.html" class="active sidebar-link">关于Generator</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/lists/关于Generator.html#单线程与协程" class="sidebar-link">单线程与协程</a></li><li class="sidebar-sub-header"><a href="/lists/关于Generator.html#协程" class="sidebar-link">协程</a></li><li class="sidebar-sub-header"><a href="/lists/关于Generator.html#协程在generator里面的实现" class="sidebar-link">协程在Generator里面的实现</a></li><li class="sidebar-sub-header"><a href="/lists/关于Generator.html#generator异步实战" class="sidebar-link">Generator异步实战</a></li><li class="sidebar-sub-header"><a href="/lists/关于Generator.html#co库" class="sidebar-link">CO库</a></li></ul></li></ul></div><div class="page"><div class="content"><h1 id="关于generator"><a href="#关于generator" aria-hidden="true" class="header-anchor">#</a> 关于Generator</h1><p>在上一盘文章里面，我们简单地介绍了Generator，我们知道执行Generator函数生成的是一个iterator遍历器，而在Generator里面的<code>yidle</code>关键字，可以通过生成的iterator遍历器的Next方法返回对象的value属性中获取。更为重要的是，可以让Generator函数的执行停止，然后再通过Iterator的next方法来重新启动。</p><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">myGen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">yield</span> <span class="token number">1</span> <span class="token comment">// 1将会作为生成next方法返回对象的value属性值,同时让函数暂停执行后面的操作</span>
    <span class="token keyword">yield</span> <span class="token number">2</span> <span class="token comment">//2 同上，作为返回对象的value属性值，并让函数暂停执行。</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> it <span class="token operator">=</span> myGen<span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//{value:1,done:false}</span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//{value:2,done:false}</span>
</code></pre></div><p>Generator的next方法不但可以返回值，还可以带上一个参数。</p><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">testGen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'started'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> num1 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token number">1</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`num1:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>num1<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> num2 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token number">2</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`num2:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>num2<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> it <span class="token operator">=</span> <span class="token function">testGen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//started</span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token comment">// num1:100</span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span> <span class="token comment">// num2:200</span>
</code></pre></div><p>在Generator函数体内的yield表达式可以让函数暂停，而生成的iterator的<code>next</code>方法可以让函数恢复执行，并把参数作为对象yield表达式的返回值。这个功能实际上是具有非常重要的语法意义，<code>next</code>方法的参数实际上是在给函数体内部注入值，这实际上，是协程在javaScript的实现，而Generator函数就是实现的关键。</p><h2 id="单线程与协程"><a href="#单线程与协程" aria-hidden="true" class="header-anchor">#</a> 单线程与协程</h2><p>在了解协程之前，我们可以先重温一下javaScript的单线程机制。</p><p>javaScript在一开始设计出来的时候就是单线程的，js作为一门在浏览器运行的脚本语言，主要是负责与用户互动，以及操作Dom。但是如果Js是多线程的，那么例如我在一个线程里面增加了某个元素，但是又在另外一个线程里面删除了这个元素，那么到底是以谁为准呢？</p><p>这势必就会导致更为复杂的的问题，所以Js在设计之初就是单线程的，这一点是毋庸置疑的。</p><p>但是单线程的缺点也是很明显的，当我们执行任务的时候，如果某个任务所耗费的时间过长，势必就造成非常多的资源浪费。</p><p>所以在Js当中任务又分为同步任务和异步任务，同步任务指哪些在主线程当中排队等待执行的任务。只有一个任务执行完毕了，才可以开始执行下一个。而异步任务则会进入任务队列当中，只有&quot;任务队列&quot;通知主线程，异步任务可以执行了，异步任务才会进入主线程。</p><p>一旦主线程里面的任务都执行完毕，系统机会去&quot;任务队列&quot;，看看里面有哪些是可以执行的异步任务。于是异步任务就会进入主线程，开始执行。</p><p>而这些异步任务，就是对应的回调函数。而回调函数又会导致我们经常说的&quot;回调地狱&quot;问题，于是后来又提出了Promise。但是Promise也不是没有缺点的，在写代码的时候，放眼看上去都是一堆<code>then</code>,语义非常不清晰，于是我们引入了协程。</p><p>那么现在我们来看看协程，到底是个什么东东？</p><h2 id="协程"><a href="#协程" aria-hidden="true" class="header-anchor">#</a> 协程</h2><p>协程，又称为微线程，英文名(coRoutine)。意思是多个线程相互协作，完成异步任务。</p><p>协程的运行流程大概如下：</p><ul><li>协程A开始运行</li><li>协程A运行到一半，暂停，把执行权交给协程B</li><li>协程B的任务完成后，再把执行权反交给协程A</li><li>协程A恢复执行</li></ul><p>而协程A就是我们的异步任务，现在我们来写一个例子</p><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span>
<span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">asyncReadFIle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token keyword">yield</span> fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>filA<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这个Generator函数中，关键就在于其中的yield命令，它可以把执行权转交出去，转交出去后函数就暂停执行了，等待执行权返回，然后从暂停的地方恢复执行。</p><h2 id="协程在generator里面的实现"><a href="#协程在generator里面的实现" aria-hidden="true" class="header-anchor">#</a> 协程在Generator里面的实现</h2><p>Generator函数就是协程在Es6里面的实现，Generator函数说白了就是一个异步任务的容器，当我们需要等待异步函数执行，需要暂停操作的地方，就用yield命令。</p><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">asyncWork</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token keyword">yield</span> x <span class="token operator">+</span> <span class="token number">2</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> it <span class="token operator">=</span> <span class="token function">asyncWork</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// {value:4,done:false}</span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// {value:undefined,true}</span>
</code></pre></div><p>Generator函数不同于普通的函数，它返回的是一个<code>iterator</code>遍历器，当代码执行到yield语句时，Generator函数的内部执行就会暂停，此时我们可以调用<code>iterator</code>的<code>next</code>方法，<code>next</code>方法会返回一个对象，在对象的value属性中，获取到相对应的yield(也就是第一个)后方的值。done属性则表示的是Generator是否执行完毕，是否有下一阶段。</p><h2 id="generator异步实战"><a href="#generator异步实战" aria-hidden="true" class="header-anchor">#</a> Generator异步实战</h2><p>接下来，就让我们看看如何用Generator来表达我们的异步任务。</p><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">readFile</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>先用一个Promise封装一下我们读取文件的异步任务。</p><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">asyncReadFile</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">readFile</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后再用Generatot把我们的异步流程表达出来，可以看到在Generator函数的内部，如果忽略我们的yield语句，函数内部就像是在执行同步代码。</p><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">asyncReadFile</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">readFile</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> g <span class="token operator">=</span> <span class="token function">asyncReadFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> result <span class="token operator">=</span> g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
result<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> data<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>执行这段代码是这样子的，执行Generator函数，获取返回的iteraotr，调用iterator的next方法，执行异步任务的第一阶段，由于<code>yield</code>命令的后方是一个Promise，此时我们在返回对象的value属性里面获取到他，然后执行<code>then</code>方法，通过<code>then</code>方法，我们获取到返回的数据，然后再把数据作为<code>next</code>方法的参数，重新传入Generator函数。</p><p>此时Generator函数中变量<code>result</code>获取的就是我们Promise返回的结果了，然后再输出出来。可以看到在Generator可以将异步的操作表示的很简洁，并且看起来就像同步一样，但是要执行他，却要花费一些心力。</p><h2 id="co库"><a href="#co库" aria-hidden="true" class="header-anchor">#</a> CO库</h2><p>既然Generator函数的执行这么麻烦，那么有没有什么东西可以让它自动执行呢？其实在很久以前，就已经有程序员解决了这个问题，他就是著名的程序员 TJ Holowaychuk，它所写的CO库，就可以自动执行Generator函数。</p><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> co <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'co'</span><span class="token punctuation">)</span>
<span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">asyncReadFile</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">readFile</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">co</span><span class="token punctuation">(</span>asyncReadFile<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'执行完成'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>Co库需要一个Generator函数作为参数，返回的还是一个Promise,于是我们就可以像写同步代码一样写异步代码，并像处理Promise一样获得我们的异步结果。</p><blockquote><p>参考文档</p><p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener noreferrer">JavaScript 运行机制详解：再谈Event Loop<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p><a href="http://es6.ruanyifeng.com/#docs/generator-async" target="_blank" rel="noopener noreferrer">Generator函数的异步应用<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote></div><div class="page-edit"><!----><!----></div><!----></div></div></div>
    <script src="/assets/js/5.08ff075f.js" defer></script><script src="/assets/js/app.56f95d45.js" defer></script>
  </body>
</html>
